{-# LANGUAGE DeriveDataTypeable, RecordWildCards #-}

import qualified Data.Set as Set
import Test.HUnit ((@=?), runTestTT, Test(..))
import Text.Printf (printf)
import System.Console.CmdArgs
import Data.List (sort, tails)

import Common (exec, EulerArg, euler_main)

-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
--     Triangle        P3,n=n(n+1)/2       1, 3,  6, 10, 15, ...
--     Square          P4,n=n2             1, 4,  9, 16, 25, ...
--     Pentagonal      P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
--     Hexagonal       P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
--     Heptagonal      P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
--     Octagonal       P8,n=n(3n−2)        1, 8, 21, 40, 65, ...
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
-- The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
-- Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
-- This is the only set of 4-digit numbers with this property.
-- Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

problem0061 :: Int -> Int -> [[Integer]]
problem0061 digits setSize = error "Not Implemented"

polyGen :: Integer -> [Integer]
polyGen n = scanl (+) 1 [(n-1), (n-2) + (n-1)..]

triangle   = polyGen 3 -- [2,3,4,5] 1
square     = polyGen 4 -- [3,5,7,9] 2 
pentagonal = polyGen 5 -- [4,7,10,13] 3
hexagonal  = polyGen 6 -- [5,9,13,17] 4
heptagonal = polyGen 7
octagonal  = polyGen 8

testPolyGen = [
    [1,3,6,10] @=? (take 4 $ polyGen 3),
    [1,4,9,16] @=? (take 4 $ polyGen 4),
    [1,5,12,22] @=? (take 4 $ polyGen 5)
    ]

unitTests = map TestCase $
    testPolyGen

data Arg = Euler | AdHoc { digits::Int, setSize::Int } | UnitTest
    deriving (Show, Data, Typeable)

instance EulerArg Arg where
    exec Euler = do
        let answer = head $ problem0061 4 6
        printf "Answer: %d\n" (sum answer)
    exec AdHoc{..} = do
        let answer = problem0061 digits setSize
        mapM_ (printf "%s\n" . show) answer
    exec UnitTest = do
        runTestTT $ TestList unitTests
        return ()

main :: IO ()
main = euler_main [Euler, AdHoc {setSize=4, digits=4}, UnitTest]

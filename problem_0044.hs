{-# LANGUAGE DeriveDataTypeable, RecordWildCards #-}

-- Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
-- 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
-- It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
-- Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

import Test.HUnit ((@=?), assertBool, runTestTT, Test(..))
import Text.Printf (printf)
import System.Console.CmdArgs
import Data.Time (getCurrentTime, diffUTCTime)

data EulerArgs = 
    Euler 
    | Sums{ limit::Int }
    | Diffs{ limit::Int }
    | UnitTest
    deriving (Show, Data, Typeable)

data PentPair = PentPair{ c::Integer, b::Integer } deriving (Eq)

p_diff (PentPair c b) (PentPair c' b') = (c - b) < (c' - b')
p_sum (PentPair c b) (PentPair c' b') = (c + b) < (c' + b')

problem0044 :: Integer
problem0044 = head $ filter (\p -> (pentFunc diff p) == (pentFunc sums p)) pentagonalNums
    where
        diff (PentPair c b) = c - b
        sums (PentPair c b) = c + b

pentFunc :: (Eq a) => (PentPair -> a) -> a -> Maybe PentPair
pentFunc = error "Not Implmeneted"

penSums = filter hasPenSum $ mergeSortBy p_sum pentPairs
    where hasPenSum (PentPair c b) = isPentagonal (c + b)

penDiffs = filter hasPenDiff $ mergeSortBy p_diff pentPairs
    where hasPenDiff (PentPair c b) = isPentagonal (c - b)

mergeSortBy :: (a -> a -> Bool) -> [[a]] -> [a]
mergeSortBy _ [] = []
mergeSortBy f ([]:ls) = mergeSortBy f ls
mergeSortBy f ((x:xs):ls) = x : (mergeSortBy f $ insertSortBy f' xs ls)
    where
        f' [] _ = True
        f' _ [] = False
        f' (x:_) (y:_) = f x y

mergeSortTest = [
    [1..5] @=? (take 5 $ mergeSortBy (<) [[x] | x <- [1..]]),
    [1..5] @=? mergeSortBy (<) [[1],[],[2,4,5],[3]],
    [] @=? mergeSortBy (<) ([]::[[Integer]]),
    "apbaeananappler" @=? mergeSortBy (<) ["apple", "pear", "banana"],
    [1..5] @=? mergeSortBy (<) [[x] | x <- [1..5]],
    [1..5] @=? mergeSortBy (<) [[x] | x <- [1..5]],
    [1] @=? mergeSortBy (<) [[1]]]

insertSortBy :: (a -> a -> Bool) -> a -> [a] -> [a]
insertSortBy _ x [] = [x]
insertSortBy f x (y:ys) = if f x y then x : y : ys else y : (insertSortBy f x ys) 

insertSortByTest = [
    [1..5] @=? insertSortBy (<) 3 [1,2,4,5],
    [1..5] @=? insertSortBy (<) 5 [1..4],
    [1..5] @=? insertSortBy (<) 1 [2..5],
    [1] @=? insertSortBy (<) 1 []]

pentPairs :: [[PentPair]]
pentPairs = worker pentagonalNums
    where
        worker (p:ps) = (map (flip PentPair p) ps) : (worker ps)

isPentagonal :: Integer -> Bool
isPentagonal p = p == (head $ dropWhile (<p) pentagonalNums)

isPentagonalTest = [
    True @=? isPentagonal 145,
    True @=? isPentagonal 70,
    True @=? isPentagonal 1,
    False @=? isPentagonal 2,
    False @=? isPentagonal 0]

pentagonalNums = [div (n * (3*n-1)) 2 | n <- [1,2..]]

unitTests = map TestCase $
    isPentagonalTest ++
    insertSortByTest ++
    mergeSortTest

exec :: EulerArgs -> IO ()
exec Euler = do
    let answer = problem0044
    printf "Answer: %d\n" answer
exec UnitTest = do 
    runTestTT $ TestList unitTests
    return ()
exec Sums{..} = do
    let sums = take limit penSums
    mapM_ (\p -> printf "%4d = %3d + %3d\n" ((c p) + (b p)) (c p) (b p)) sums
    return ()
exec Diffs{..} = do
    let diffs = take limit penDiffs
    mapM_ (\p -> printf "%4d = %3d - %3d\n" ((c p) - (b p)) (c p) (b p)) diffs
    return ()

main :: IO ()
main = do
    args <- cmdArgs $ modes [Euler, Sums{ limit=100 }, Diffs{ limit=100 }, UnitTest]
    start <- getCurrentTime
    exec args
    stop <- getCurrentTime
    print $ diffUTCTime stop start
